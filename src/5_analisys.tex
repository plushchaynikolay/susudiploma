\section{АНАЛИЗ ПРОЕКТОВ}
    \subsection{Метрики}
    Целью реинжениринга проекта было улучшение его ясности, надежности и поддерживаемости,
    модифицируемости, для этого нужно максимально уменьшить сложность и сцепленность кода,
    увеличить покрытие кода тестами.
    Для оценки успешности выполненных работ, применим метрики размера,
    стилистики и сложности программы.
    \cite{clearcode.habr}

    Для оценки изменений в объеме кодовой базы подсчитаем количества строк
    (LOC-метрика, \textit{lines of code}) кода в проекте.
    Для оценки стилистики и понятности подсчитаем количество модулей и средний
    объем модуля -- это даст нам понять, насколько изменилась читаемость кода,
    ведь чем больше текст программы, тем сложнее удержать во внимании суть при 
    её изучении. Также подсчитаем количество пустых строк, чтобы оценить
    "разряженность" текста программы.

    При этом мы не станем подсчитывать степень документированности кода,
    так как в текущей команде разработчиков не поощряется комментирование.
    Такое решение было принято из тех принципов,
    что код должен быть понятен без комментариев,
    что отсутствие комментариев вынуждает программиста придумывать лучшие имена
    для переменных и функций,
    и что комментарии необходимо регулярно актуализировать, а делать это
    гораздо сложно, так как комментарии, в отличие от кода,  нельзя
    протестировать.
    Можно добавить, что в рекомендациях PEP отмечается, что отсутствующий
    комментарий лучше неправильного.

    Цикломатическая сложность программы - количество независимых маршрутов через
    неё. Вычисляется с помощью ориентированного графа, узлами которого являются
    блоки программы, соединенные рёбрами, если управление может переходить с
    одного блока на другой. Определяется как:
    \begin{center}
        $ M = E - N + 2P $, 
    \end{center}
    где:
    \begin{description}
        \item [M] - цикломатическая сложность,
        \item [E] - количество рёбер в графе,
        \item [N] - количество узлов в графе,
        \item [P] - количество компонент связности.
    \end{description}
    Цикломатическая сложность любой структурированной программы с только одной
    точкой входа и одной точкой выхода эквивалентна числу точек ветвления,
    то есть, операторов if или условных циклов, плюс один.
    \cite{complexity.McCabe}

    Индекс поддерживаемости -- это метрика, отвечающая количественно на вопрос
    о том, насколько легко править и изменять исходный код проекта.
    Рассчитывается индекс по следующей формуле \cite{metrics.cmcons}:
    \begin{center}
        $ MI = 171 - 5.2 \ln V - 0.23G - 16.2 \ln L $,
    \end{center}
    где:
    \begin{description}
        \item [V] - объем программы по Холстеду,
        \item [G] - цикломатическая сложность,
        \item [L] - количество строк кода.
    \end{description}

    Объем программы по Холстеду относится к серии метрик, позволяющих оценить
    усилия программиста при разработке, и основывается на анализе числа строк
    и синтаксических элементов исходного кода программы.
    \begin{center}
        $ V = HPLen \log_{2}HPVoc $
    \end{center}
    где:
    \begin{description}
        \item [HPVoc] - словарь программы,
        $ HPVoc = NUOprtr + NUOprnd $
        \item [HPLen] - длина программы,
        $ HPLen = Noprtr + Noprnd $
        \item [NUOprtr, NUOprnd] - число уникальных операторов и операндов,
        \item [Noprtr, Noprnd] - общее число уникальных операторов и операндов.
    \end{description}

    \subsection{Сравнение}
    Для подсчета модулей и классов воспользуемся unix утилитами \textit{ls, wc, grep}.

    Подсчет цикломатической сложности, метрики сложности Холстеда и индекса
    поддерживаемости будем осуществлять при помощи утилиты для
    анализа Python приложений \textit{radon} \cite{complexity.radon}.
    Для сравнения в таблице возьмем среднюю сложность по всем модулям, классам
    и функциям проекта.
    
    Для определения степени покрытия кода тестами воспользуемся расширением для
    \textit{pytest}, которое называется \textit{pytest-cov}
    \cite{test.pytest.cov}.
    По итогу работы утилиты, получаем лог, представленный ниже, из которого
    следует, что текущее покрытие тестами составляет 79\%.
    \begin{figure}[H]
        \centering
        \lstinputlisting{snippets/pytest-coverage.log}
        \caption{Результат анализа покрытия кода тестами}
        \label{fig:pytest-coverage}
    \end{figure}

    \begin{table}[H]
        \caption{Сравнение метрик программного обеспечения проектов}
        \begin{center}
            \begin{tabular}{l|r|r}
                \textbf{Метрика} & \textbf{Исходный} & \textbf{Конечный} \\
                \hline
                Количество строк кода, LOC    & 1511    & 2022 \\
                Количество пустых строк       & 198     & 329 \\
                Разряженность, \%             & 13.1    & 16.3 \\
                Количество модулей            & 67      & 87 \\
                Среднее число строк на модуль & 110.99  & 67.66 \\
                Количество классов            & 100     & 182 \\
                Цикломатическая сложность     & 2.4903  & 2.1176 \\
                Сложность (Холстед)           & 2.121   & 1.047 \\
                Поддерживаемость              & 61.53   & 80.73 \\
                Покрытие тестами, \%          & 0       & 79 \\
            \end{tabular}
        \end{center}
    \end{table}

    \subsection*{Вывод по главе 6}
    % TODO Вывод по главе 6
