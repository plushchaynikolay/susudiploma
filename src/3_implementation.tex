\section{РЕАЛИЗАЦИЯ}
    \subsection{Уведомления}
    Выполнение несрочных задач в проекте выполняется менеджером отложенных задач
    \textit{Celery} -- это широко известный кроссплатформенный проект с открытым 
    исходным кодом на Python для асинхронного выполнения задач через вызов удаленных процедур.
    В качестве брокера задач мы используем RabbitMQ -- брокер сообщений реализующий 
    протокол AMQP\cite{docs.rabbitmq}.
    Для добавления задач в очередь в нашем проекте используются "уведомления" (\inlinecode{Notifier}).
    Перечислим все виды уведомлений, которые существуют на настоящий момент:
    \begin{itemize}
        \item \inlinecode{DataBaseMessageNotifier} -- сохранение сообщения в базу;
        \item \inlinecode{DataBaseResponseNotifier} -- сохранение ответов в базу;
        \item \inlinecode{DataBaseCarefulNotifier} -- сохранение сообщения в базу, если оно ещё не существует;
        \item \inlinecode{AppLogerNotifier} -- уведомление о некоторых событиях в мессенджер.
    \end{itemize}
    Пример реализации сохранения в базу представлен на рисунке 10.

    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/data_base_message_notifier.py}
        \caption{Код класса DataBaseMessageNotifier}
        \label{fig:data_base_message_notifier}
    \end{figure}

    Сама Celery-задача выглядит так, как представлено на рисунке 11:

    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/celery_task.py}
        \caption{Код метода-задачи Celery save\_to\_db}
        \label{fig:celery_task}
    \end{figure}

    \subsection{Работа с базой}
    В работе с базой данных участвуют две сущности: объектно-реляционная модель Message
    и класс инкапсулирующий работу с базой DataBaseProvider.
    Модель Message выглядит так, как представлено на рисунке 12:

    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/message_model.py}
        \caption{Код ОРМ класса Message}
        \label{fig:message_model}
    \end{figure}

    DataBaseProvider -- это довольно большой статический класс, реализующий
    как получение истории сообщений,
    так и сохранение новых сообщений в базу.
    Структура класса приведена на рисунке 13.

    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/dbprovider.py}
        \caption{Код класса DataBaseProvider}
        \label{fig:DataBaseProvider}
    \end{figure}

    Рассмотрим подробнее методы этого класса:
    \begin{itemize}
        \item \inlinecode{get_history} -- публичный метод для получения истории диалога, осуществляет
        безопасную выгрузку истории чата из базы данных, обрабатывая возникающие исключения;
        \item \inlinecode{_load_history} -- приватный метод, реализующий непосредственную загрузку истории из базы,
        устанавливает временной диапазон истории и формирует результат в надлежащий вид;
        \item \inlinecode{get_latest_datetime} -- метод получения информации о времени последнего сообщения
        в канале или чате, от пользователя, оператора или бота;
        \item \inlinecode{save} -- сохранение нового сообщения в базе, реализует SQL-функцию \inlinecode{INSERT};
        \item \inlinecode{get_or_create} -- создание записи о сообщении в базе, если в этом канале сообщения с таким
        идентификатором ещё не существует, реализует SQL-функцию \inlinecode{IF NOT EXISTS INSERT};
        \item \inlinecode{update_or_create} -- обновление записи в базе о сообщении определенного канала с таким
        идентификатором, либо создание новой записи, реализует SQL-функцию \inlinecode{IF EXISTS UPDATE ELSE INSERT};
        \item \inlinecode{_save} -- непосредственная реализация трех перечисленных выше функций,
        выбирая нужный метод библиотеки \textit{Django} подставляет нужные фильтры поиска и значения для создания
        или обновления записи.
    \end{itemize}

    \subsection{Датаклассы}
    С версией \textit{Python 3.8} в синтаксис языка был добавлен новый синтаксис
    для создания датаклассов.
    В проекте существуют несколько представителей датаклассов. Опишем отдельно каждого из них.
    \begin{enumerate}
        \item Класс \inlinecode{MessageData} -- датакласс для описания сообщений входящих и исходящих,
        содержит всю необходимую для работы обработчика, сценариста и других классов информацию:
        идентификатор чата, название канала-источника, время получения, отправителя,
        список классифицированных категорий, а также некоторые флаги и идентификаторы.
        Код с описанием этого класса представлен на рисунке 14.

        \begin{figure}[H]
            \centering
            \lstinputlisting[language=Python]{snippets/messagedata.py}
            \caption{Код класса MessageData}
            \label{fig:messagedata}
        \end{figure}

        \item Класс \inlinecode{Answer} -- контейнер с ответом бота на входящее сообщение.
        Код с описанием этого класса представлен на рисунке 15.

        \begin{figure}[H]
            \centering
            \lstinputlisting[language=Python]{snippets/answer.py}
            \caption{Код класса Answer}
            \label{fig:answer}
        \end{figure}

        \item Класс \inlinecode{Prediction} -- контейнер с результатами классификации текста сообщения,
        которые возвращает классификатор.
        Код с описанием этого класса представлен на рисунке 16.

        \begin{figure}[H]
            \centering
            \lstinputlisting[language=Python]{snippets/prediction.py}
            \caption{Код класса Prediction}
            \label{fig:prediction}
        \end{figure}

        \item Класс \inlinecode{ResponseData} -- датакласс со всем, что нужно боту, чтобы корректно
        среагировать на входящее сообщение пользователя.
        Код с описанием этого класса представлен на рисунке 17.

        \begin{figure}[H]
            \centering
            \lstinputlisting[language=Python]{snippets/responsedata.py}
            \caption{Код класса ResponseData}
            \label{fig:responsedata}
        \end{figure}

    \end{enumerate}

    \subsection{Канал telegram}
    Так как за обработку отложенных действий теперь отвечает менеджер задач \textit{Celery},
    исчезла потребность в асинхронной обработке сообщений, мы отказались от асинхронности.
    Это позволяет использовать синхронные библиотеки, выбор которых гораздо больше,
    а логика синхронных приложений гораздо проще для понимания.
    В новой реализации telegram-канала была использована другая библиотека -- \textit{pyrogram}\cite{docs.pyrogram}.
    Структура \inlinecode{TelegramWorker} осталась примерно той же: два фильтра событий и две функции, описывающие
    обработку входящих и исходящих сообщений подаются в цикл обработки событий (\textit{event loop})
    telegram клиента.
    Обработка сообщений заключается в их преобразовании во внутренний тип \inlinecode{MessageData}
    и передаче обработчику в \inlinecode{IncomingHandler} или в \inlinecode{OutgoingHandler}.
    \inlinecode{TelegramApiWrapper} наследуется от базового класса \inlinecode{ApiWrapper},
    реализует его абстрактные методы \inlinecode{send_message} и \inlinecode{convert_from_api_message_type}.

    \subsection{Канал ВКонтакте}
    Для реализации канала ВКонтакте используется
    библиотека \textit{vk\_api}\cite{docs.vkapi}.
    Для получения сообщений используется технология LongPoll, в которой, после
    установления соединения и начала сессии, клиент получает
    от сервера ВКонтакте уведомления о всех новых событиях в беседе.
    У каждого нового события проверяется
    является ли оно сообщением, а также поле \inlinecode{to_me}, из которого определяется каким образом
    должно обрабатываться сообщение, как входящее или исходящее.
    Обработка сообщений, также как и в случае с telegram, заключается в их преобразовании во внутренний тип
    и передаче одному из обработчиков.

    \subsection{Канал почты}
    Ввиду отсутствия у библиотек по работе с почтой инструментов, похожих на LongPoll, этот инструмент был
    создан самостоятельно. Для этого мы поочередно просматриваем папки входящей и исходящей почты на наличие
    непрочитанных и необработанных ботом сообщений. Также был объявлен специальный датакласс \inlinecode{EmailMessage}
    канала почты, со специальными полями, и класс \inlinecode{EmailMessageBuilder} для создания объекта датакласса.
    Дополнительно были созданы классы обертки над библиотеками \textit{imap} и \textit{smtp}, в которых
    реализован алгоритм установления и проверки соединения и переподключения в случае его разрыва.
    На почте присутствует сложная логика, связанная пометкой обработанных ботом сообщений флажком
    и перекладыванием отвеченных сообщений в отдельную папку. Дополнительно ситуация осложняется тем, что
    одновременно в одном почтовом ящике могут работать кроме бота ещё два оператора и сторонний парсер почты,
    из-за чего часто возникают конфликтные ситуации. Ситуации могут выражаться, например в прочтении и снятии флага
    \inlinecode{unseen} с писем, предназначенных для бота, и так далее. Поэтому обработка писем в этом канале перегружена
    различными дополнительными проверками.

    \newpage
    \subsection{Web API чат-бота}
    Чат-бот также предоставляет web API для внешнего использования и интеграции
    в коммуникационные и консультационные системы. Реализован веб-интерфейс на
    основе возможностей и библиотек фреймворка Django. Приложение принимает POST-запрос
    с json-объектом, содержащим идентификатор чата, имя канала, текст и дату сообщения.
    В ответ возвращается json-объект с массивом ответов -- объектов класса \inlinecode{Answer}.
    Это единственный канал, в который работает не через \inlinecode{ApiWorker.run},
    потому что не использует внешний API, а предоставляет его.
    Вместо этого канал работает через класс \inlinecode{ApiManager}, который имеет
    единственный метод \inlinecode{ApiManager.handle_message}. Этот метод, в отличие от
    \inlinecode{ApiWorker.run} принимает json-объект сообщения и возвращает также json-объект ответа.
    Примеры этих объектов приведены на рисунке 18.
    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/request.json}
        \lstinputlisting[language=Python]{snippets/response.json}
        \caption{Примеры запроса (сверху) и ответа (снизу)}
        \label{fig:json-req-resp}
    \end{figure}
    То есть, в этом канале не используется метод \inlinecode{ApiWrapper.send_message},
    так как ответ на сообщение пользователя возвращается в ответ на запрос незамедлительно.

    \subsection{Сценарист и сценарии}
    Диалоговая система в целом не перенесла существенных изменений, так как целью рефакторинга не ставилось
    улучшение точности или полноты распознавания. Изменения претерпел только модуль для разработки и сборки модели.
    Он был перенесен в рабочий проект целиком, практически без изменений, в корневую директорию нового проекта.
    В первую очередь, это было нужно, чтобы решить проблему импортов библиотек при распаковке модели.
    Дело в том, что для сериализации модели в проекте используется библиотека 
    \textit{joblib}, которая при сериализации
    классов, использованных в составе модели, сохраняет пути импортов,
    а при десериализации использует те же пути для распаковки.
    Проблема заключается в том, что пути импортов сохраняются относительно точки запуска скрипта сборки, или,
    в нашем случае, \textit{jupyter} тетрадки с кодом сборки.
    Как следствие, если путь входа в приложение будет иным,
    импорты провалятся и приложение завершится с ошибкой.
    Размещение скриптов для сборки модели и запуска приложения в одном каталоге -- самое легкое и очевидное
    решение, в дальнейшем позволяет не отвлекаться на проблему загрузки модели во время работы над ней.

    \subsection{Обработчик}
    Для обработки сообщений был реализован базовый класс \inlinecode{MessageHandler}, в котором объявлен
    абстрактный метод \inlinecode{handle()} и реализован общий для входящих и исходящих сообщений
    метод \inlinecode{notify}, который рассылает уведомления всем заявленным уведомителям.
    Метод \inlinecode{handle()} содержит реализуется в виде перечня последовательных действий,
    которые должны быть проделаны над сообщением.

    В \inlinecode{IncomingHandler} это вызов сценариста для формирования ответа, отправка ответных сообщений,
    отправка уведомлений, выполнение дополнительных действий. Листинг метода представлен на рисунке 19.

    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/incomig_handler_handle.py}
        \caption{Код класса IncomingHandler}
        \label{fig:incomig_handler_handle}
    \end{figure}

    В \inlinecode{OutgoingHandler} никаких действий кроме отправки уведомлений не требуется.
    Реализация этого класса представлена на рисунке 20.

    \begin{figure}[H]
        \centering
        \lstinputlisting[language=Python]{snippets/outgoing_handler.py}
        \caption{Код класса OutgoingHandler}
        \label{fig:outgoing_handler}
    \end{figure}

    \subsection*{Вывод по главе 3}
    В этой главе мы описали все реализованные нами классы и методы, объяснили принципы
    их работы и перечислили некоторые связанные с ними нюансы.
    Для наглядности мы привели листинги кода.
    В ходе самой разработки были решены основные проблемы, перечисленные в первой главе данной работы.
    Проект переписан с единой архитектурой для всех каналов чат-бота что улучшает понимание и поддержку
    проекта, для работы с базой теперь используется объектно-реляционная модель, что также сильно
    упрощает поддержку и написание нового функционала,
    проект полностью снабжен аннотациями типов, что позволяет проводить статический анализ.
