\section{АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ}
    \subsection{Анализ исходных данных}
    Существующий проект выполняет задачи сбора сообщений с социальных сетей, мессенджеров и почты,
    их классификации и рассылки ответов пользователям.
    Проект оснащен системой непрерывной сборки и развертывания (CI/CD Pipeline), интегрированной в
    систему управления репозиториями \textit{GitLab}\cite{docs.gitlab}.
    Кодовая база проекта, как и сам проект, разделены на пять репозиториев с различными
    функциональными частями.
    
    Ниже представлен их список:
    \begin{enumerate}
        \item Приложения по работе с каналами
        \item API чат-бота для внешнего использования
        \item Диалоговая система чат-бота
        \item Обучение модели классификатора
        \item Система мониторинга и разметки сообщений
        \item Прокси-сервер и мониторинг нагрузки
    \end{enumerate}
    
    Все приложения собираются и разворачиваются внутри docker контейнеров.
    Приложения по работе с каналами выполнены на языке \textit{Python} как асинхронные приложения
    с использованием библиотеки \textit{asyncio} и асинхронных библиотек.
    API чат-бота выполнено также на языке \textit{Python} с использованием веб-фреймворка \textit{Flask}.
    Оба эти подпроекта используют диалоговую систему, в которой реализован непосредственный
    классификатор сообщений.
    Диалоговая система импортируется как библиотечный модуль через внутренний репозиторий
    программного обеспечения \textit{PyPI}.
    При появлении обновления в репозитории диалоговой системы срабатывает триггер CI/CD пайплайна
    в приложениях каналов и API, и их контейнеры пересобираются с новой версией библиотеки.
    Система мониторинга реализована на языке \textit{Python} как \textit{Django} веб-приложение.
    Для мониторинга используется администраторская доска управления \textit{Django} приложения.
    В ней же реализован подсчет статистики и \textit{SQL-explorer} для запросов в базу данных.
    Прокси-сервер работает поверх всех сервисов, а именно: API-сервис, система мониторинга,
    системы оповещения и мониторинга ошибок \textit{Sentry}\cite{docs.sentry}, система мониторинга
    нагрузки \textit{Prometheus} с выводом графики через \textit{Grafana}.
    Он перераспределяет http-запросы к поддоменам на конкретные приложения и сервисы.

    Разберем подробнее основные функциональные элементы, это:
    приложение по работе с каналами, API-сервис и диалоговая система.
    
    \subsubsection*{Приложение по работе с каналами}
    Приложение работает по трем каналам: ВКонтакте, telegram и почта. Логику работы всех трех каналов можно обобщить
    следующим образом: в цикле поочередно обрабатываются входящие  и исходящие письма, входящие письма дополнительно
    классифицируются, к ним вырабатывается и отправляется ответное сообщение, затем входящее или исходящее сообщение
    сохраняется в базу. Для сохранения в базу используется асинхронная библиотека \textit{asyncpg},
    сохранение происходит через формирование сырого SQL-запроса.
    Для канала ВКонтакте используется библиотека \textit{vk\_api},
    канала telegram используется асинхронная библиотека \textit{telethon},
    канала почты используется библиотека \textit{IMAPClient}\cite{docs.imap} 
    и встроенная библиотека \textit{smtp}.

    Обработчик канала телеграм представляет собой класс с двумя методами,
    в которых описано вся обработка сообщения от его получения и до отправки ответа
    и произведения записей в базу данных. Такой подход к описанию обработки сообщений
    привел к появлению больших методов на несколько десятков строк кода, что является
    признаком <<кода с душком>>.

    В каналах почты и ВКонтакте кроме двух крупных основных публичных методов
    присутствует много приватных вспомогательных методов, которые были введены с
    целью разгрузить и разграничить основные, но в итоге это привело к появлению
    больших классов с десятью и двенадцатью не менее крупными методами.
    При этом эти классы имеют мало, одно или два, взаимодействия с другими классами.
    То есть существуют и работают без должного разделения ответственности.

    При изменении в логике обработки сообщения, не связанном с конкретным API канала,
    необходимо вносить изменения во все три класса, при чем масштабы изменений и
    сама их суть, могут существенно отличаться.
    Такая проблема называется <<стрельба дробью>>.
    Также в коде нередко встречаются комментарии, поясняющие его работу, что говорит
    о том, что код сложен для понимания, требует разбиения на блоки, методы и классы
    с хорошими наименованиями, ясно отражающими свою сущность. \cite{refactoring.fowler}

    \subsubsection*{API-сервис}
    Сервис получает POST запросы по HTTP протоколу с текстом сообщения пользователя и отправляет ответ,
    сформированный с использованием диалоговой системы. Также сохраняет сообщения в базу через исполнение сырого sql.

    Код в web API, кроме самого веб-приложения, полностью дублирует код приложении по работе с каналами.
    Код не может быть удобно переиспользован, так как исходные коды проектов размещены в разных
    репозиториях.

    \subsubsection*{Диалоговая система}
    Диалоговая система состоит из двух основных сущностей: сценариста и классификатора. Сценарист отвечает за формирование ответных
    сообщений и дополнительных действий на входящее сообщение, задачу классификации при этом он делегирует классификатору.
    Классификатор является двухуровневым. На первом уровне это, так называемый, \textit{rule-based} классификатор
    основанный на ключевых и стоп-паттернах в виде регулярных выражений. Если на первом уровне предсказание не было выработано,
    задействуется второй уровень, с моделью машинного обучения. Такой двух уровневый подход позволяет
    регулировать работу классификатора при помощи фильтров-паттернов на первом уровне, не допуская сообщения с
    заранее известными шаблонами до модели машинного обучения, такими образом, повышая точность предсказаний.
    С другой стороны, модель машинного обучения обладает более высокой полнотой предсказаний, что повышает
    количество ответов чат-бота.

    \subsection{Анализ проблемных мест}
    После анализа исходного кода проекта мы можем выделить некоторые проблемные места, которые постараемся решить во время
    реинжиниринга и рефакторинга. Ниже представлен полный список пробелем исходного проекта:
    \begin{enumerate}
        \item Алгоритм сохранения сообщений в базу для приложений каналов и API-сервиса одинаков, но никак не обобщен в коде.
        \item Сохранение в базу через сырой SQL-запрос неудобно, часто приводит
        к ошибкам во время исполнения, которые сложно отследить на этапе разработки.
        \item Каналы чат-бота имеют одинаковую логику, общность которой никак не описана. 
        \item Многие параметры работы каналов не вынесены в конфигурационные файлы, а жестко прописаны прямо в коде.
        \item Процедурный стиль написания кода, без объявления интерфейсов и классов затрудняет понимание.
        \item Отсутствует типизация, невозможен статический анализ.
        \item Отсутствуют модульные и интеграционные тесты.
        \item Код в целом имеет низкий уровень абстракции.
        \item Код во многом дублируется.
    \end{enumerate}

    \subsection{План выполнения работ}
    Исходя из анализа выявленных проблемных мест было принято решение о проведении реинжиниринга всего проекта.
    Для новой реализации проекта был выбран фреймворк \textit{Django}\cite{docs.django}, так как он обладает множеством инструментов
    для работы с вебом, базами данных, тестированием, имеет интеграции с множеством инструментов, таких, например,
    как менеджер отложенных задач \textit{Celery}\cite{docs.celery} и система мониторинга ошибок \textit{Sentry},
    а также задает строгий скелет проекта, одинаковый для всех проектов, написанных с использованием этого фреймворка.
    Для этого будут совершены следующие действия:
    \begin{enumerate}
        \item Объединение в один проект пяти подпроектов: приложения по работе с каналами, API-сервиса и диалоговой системы,
        а также системы мониторинга и модуля разработки модели машинного обучения.
        \item Описание общих интерфейсов и алгоритмов для всех каналов и сервиса.
        \item Использование объектно-реляционной модели (\textit{ORM}) и миграций для работы с базой данных
        Postgres\cite{postgres.stepic}.
        \item Использование инструментов статической типизации для \textit{Python} из модуля \textit{typing}
        и средств статического анализа \textit{mypy}\cite{docs.python}.
        \item Максимальное покрытие кода тестами. Для этого будем использовать
        инструменты \textit{unittest}\cite{docs.python} для unit-тестирования, \textit{tavern} для тестирования API,
        \textit{django-test} для интеграционных тестов с базой данных, \textit{pytest} для управления всеми тестами.
    \end{enumerate}

    \subsection*{Вывод по главе 1}
    В этой главе мы в достаточной степени подробно описали исходный проект, выявили основные его
    недостатки, составили план выполнения работ по улучшению кодовой базы, поддерживаемости и модифицируемости.
    Теперь мы можем приступать к следующему этапу проектирования.
