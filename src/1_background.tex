\section{АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ}
    \subsection{Анализ исходных данных}
    Существующий проект выполняет задачи сбора сообщений с социальных сетей, мессенджеров и почты,
    их классификации и рассылки ответов пользователям.
    Проект оснащен системой непрерывной сборки и развертывания (CI/CD Pipeline), интегрированной в
    систему управления репозиториями \textit{GitLab}.
    Кодовая база проекта, как и сам проект, разделены на пять репозиториев с различными
    функциональными частями.
    
    Ниже представлен их список:
    \begin{enumerate}
        \item Приложения по работе с каналами
        \item API чат-бота для внешнего использования
        \item Диалоговая система чат-бота
        \item Система мониторинга и разметки сообщений
        \item Прокси-сервер и мониторинг нагрузки
    \end{enumerate}
    
    Все приложения собираются и разворачиваются внутри docker контейнеров.
    Приложения по работе с каналами выполнены на языке \textit{Python} как асинхронные приложения
    с использованием библиотеки \textit{asyncio} и асинхронных библиотек.
    API чат-бота выполнено также на языке \textit{Python} с использованием веб-фреймворка \textit{Flask}.
    Оба эти подпроекта используют диалоговую систему, в которой реализован непосредственный
    классификатор сообщений.
    Диалоговая система импортируется как библиотечный модуль через внутренний репозиторий
    программного обеспечения \textit{PyPI}.
    При появлении обновления в репозитории диалоговой системы срабатывает триггер CI/CD пайплайна
    в приложениях каналов и API, и их конейнеры пересобираются с новой версией библиотеки.
    Система мониторинга реализована на языке \textit{Python} как \textit{Django} веб-приложение.
    Для мониторинга используется администраторская доска управления \textit{Django} приложения.
    В ней же реализован подсчет статистики и \textit{SQL-explorer} для запросов в базу данных.
    Прокси-сервер работает поверх всех сервисов, а именно: API-сервис, система мониторинга,
    системы оповещения и мониторинга ошибок \textit{Sentry}, система мониторинга нагрузки \textit{Prometheus}
    с выводом графики через \textit{Grafana}. Он перераспределяет http-запросы к поддоментам на конкретные
    приложения и сервисы.

    Функциональная схема проекта представлена на рисунке ниже.
    \begin{figure}[!h]
        \centering
        % TODO
        % \includegraphics[width=\linewidth]{}
        \caption{Функциональная схема исходного проекта}
        \label{fig:func-schema-before}
    \end{figure}
    
    Разберем подробнее основные функциональные элементы, это: приложение по работе с каналами, API-сервис и диалоговую систему.
    
    \subsubsection*{Приложение по работе с каналами}
    Приложение работает по трем каналам: Вконтакте, Телеграм и почта. Логику работы всех трех каналов можно обощить
    следующим образом: в цикле поочередно обрабатываются входящие  и исходящие письма, входящие письма дополнительно
    классифицируются, к ним вырабатывается и отправляется ответное сообщение, затем входящее или исходящее сообщение
    сохраняется в базу. Для сохранения в базу используется библиотека \textit{}, сохранение происходит через формирование
    сырого SQL-запроса.
    
    Для канала Вконтакте используется библиотека \textit{}, функциональная схема представлена ниже:
    \begin{figure}[!h]
        \centering
        % TODO
        % \includegraphics[width=\linewidth]{}
        \caption{Функциональная схема канала Вконтакте}
        \label{fig:func-schema-vk-before}
    \end{figure}

    Для канала Телеграм используется библиотека \textit{}, функциональная схема представлена ниже:
    \begin{figure}[!h]
        \centering
        % TODO
        % \includegraphics[width=\linewidth]{}
        \caption{Функциональная схема канала Телеграм}
        \label{fig:func-schema-tg-before}
    \end{figure}
    
    Для канала почты используется библиотека \textit{IMAPClient} и \textit{smtp},
    функциональная схема представлена ниже:
    \begin{figure}[!h]
        \centering
        % TODO
        % \includegraphics[width=\linewidth]{}
        \caption{Функциональная схема канала почты}
        \label{fig:func-schema-email-before}
    \end{figure}

    \subsubsection*{API-сервис}
    Сервис получает POST запросы по HTTP протоколу с текстом сообщения пользователя и отправляет ответ,
    сформированный с использованием диалоговой системы. Также сохраняет сообщения в базу через исполнение сырого sql.

    Функциональная схема работы сервиса представлена ниже:
    \begin{figure}[!h]
        \centering
        % TODO
        % \includegraphics[width=\linewidth]{}
        \caption{Функциональная схема API-сервиса}
        \label{fig:func-schema-api11-before}
    \end{figure}

    \subsubsection*{Диалоговая система}
    Диалоговая система состоит из двух основных сущностей: сценариста и классификатора. Сценарист отвечает за формирование ответных
    сообщений и дополнительных действий на входящее сообщение, задачу классификации при этом он делегирует классификатору.
    Классификатор является двухуровневым. На первом уровне это, так называемый, \textit{rule-based} классификатор
    основанный на ключевых и стоп-паттернах в виде регулярных выражений. Если на первом уровне предсказание не было выработано,
    задействуется второй уровень, с моделью машинного обучения. Такой двух уровневый подход позволяет
    регулировать работу классификатора при помощи фильтров-паттернов на первом уровне, не допуская сообщения с
    заранее известными шаблонами до модели машинного обучения, такими образом, повышая точность предсказаний.
    С другой стороны, модель машинного обучения обладает более высокой полнотой предсказаний, что повышает
    количество ответов чат-бота.

    \subsection{Анализ проблемных мест}
    После анализа исходного кода проекта мы можем выделить некоторые проблемные места, которые постараемся решить во время
    реинжениринга и рефакторинга. Ниже представлен полный список пробелем исходного проекта:
    \begin{enumerate}
        \item Алгоритм сохранения сообщений в базу для приложений каналов и API-сервиса одинаков, но никак не обобщен в коде.
        \item Сохранение в базу через сырой SQL-запрос небезопасно, подвергает систему к риску sql-иньекций кода, часто приводит
        к ошибкам во время исполнения, которые сложно отследить на этапе разработки.
        \item Каналы чат-бота имеют одинаковую логику, общность которой никак не описана. 
        \item Многие параметры работы каналов не вынесены в конфигурационные файлы, а жестко прописаны прямо в коде.
        \item Процедурный стиль оформления кода, без объявления интерфейсов и классов затрудняет понимание кода,
        а внесение любых изменений становится опасным и требует последующей кропотливой отладки.
        \item Отсутствует какая-либо типизация, невозможен статический анализ кода.
        \item Отвутствуют какие-либо тесты.
        \item Код в целом имеет низкий уровень абстракции, во многом дублируется.
    \end{enumerate}

    \subsection{План выполнения работ}
    Исходя из анализа выявленных проблемных мест было принятно решение о проведении реинжениринга всего проекта.
    Для новой реализации проекта был выбран фреймворк \textit{Django}, так как он обладает множеством инструментов
    для работы с вебом, базой данных, тестированием, имеет интеграции с множеством других инструментов, таких, например,
    как менеджер отложенных задач \textit{Celery} и система мониторинга ошибок \textit{Sentry},
    а также задает строгий скелет проекта, одинаковый для всех проектов, написанных с использованием этого фреймворка.
    Для этого будут совершены следующие действия:
    \begin{enumerate}
        \item Объединение в один проект трех подпроектов: приложения по работе с каналами, API-сервиса и диалоговой системы.
        \item Описание общих интерфейсов и алгоритмов для всех каналов и сервиса.
        \item Использование объектно-реляционной модели (\textit{ORM}) и миграций для работы с базой данных.
        \item Использование инструментов статической типизации для \textit{Python} из модуля \textit{typing}
        и средств статического анализа \textit{mypy}.
        \item Использование подходов разработки через тестирование и максимальное покрытие кода тестами. Для этого
        будем использовать иснтрументы \textit{unittest} для юнит-тестирования, \textit{tavern} для тестирования API,
        \textit{django-test} для интеграционных тестов с базой данных, \textit{pytest} для управления всеми тестами.
    \end{enumerate}

    \subsection*{Вывод по главе 1}
    В этой главе мы в достаточной мере подробно описали исходный проект, выявили основные его
    недостатки, составили план выполнения работ по улучшению кодовой базы, модифицируемости
    и функциональности. Теперь мы можем приступать к этапу проектирования.
