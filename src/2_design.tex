\section{ПРОЕКТИРОВАНИЕ}
    \subsection{Концептуальная модель обработки сообщений}
    Процесс обработки сообщения можно разделить на несколько этапов.
    \begin{enumerate}
        \item Получение сообщения через интерфейс (IMAP, LongPoll ВКонтакте, telegram-api, json-файл из POST-запроса)
        \item Извлечение необходимых полей из инородной структуры данных и преобразование в обьект-сообщение внутреннего типа
        \item Классификация сообщения
        \item Формирование ответов на сообщение
        \item Отправка ответов обратно через внешний интерфейс пользователю
        \item Сохранение всех сообщений в базу
        \item Выполнение дополнительных действий (запрос обратной связи от пользователя, уведомления и прочее)
    \end{enumerate}

    Таким образом, за каждый из этапов обработки сообщения отвечать будет свой отдельный объект,
    а взаимодействие этих объектов будет происходить при переходе от одного этапа к другому.
    
    \subsection{Описание участников обработки сообщений}
    \subsubsection*{ApiWorker}
    Объект, ответственный за первый этап -- \inlinecode{ApiWorker}. Ответственен за получение
    исходящих сообщений -- от пользователя, и входящих сообщений -- от оператора и бота.
    Его интерфейс очень прост -- это одна функция, которая запускает процесс получения новых сообщений.
    Выглядит интерфейс так, как представлено на листинге ниже.

    \begin{figure}[!h]
        \centering
        \lstinputlisting[language=Python]{snippets/api_worker.py}
        \caption{Код класса ApiWorker}
        \label{fig:api_worker}
    \end{figure}

    \subsubsection*{ApiWrapper}
    Объект, ответственный за взаимодействие с протоколами обмена сообщениями: IMAP, SMTP, VkLongPoll,
    Telegram-api и предоставляемого нами api.
    Он занимается превращением полученного сообщения в сообщение внутреннего формата проекта,
    обратным превращением перед отправкой сообщения пользователю и собственно отправкой.
    Его интерфейс выглядит следующим образом:

    \begin{figure}[!h]
        \centering
        \lstinputlisting[language=Python]{snippets/api_wrapper.py}
        \caption{Код класса ApiWrapper}
        \label{fig:api_wrapper}
    \end{figure}
    
    Метод \inlinecode{send_answers} отправляет все ответы из списка, дополняя их
    необходимой информацией от сервера текущего канала. 
    Метод \inlinecode{send_message} отправляет одно отельное сообщения по текущему каналу,
    возвращает то же сообщение, но дополненное информацией от сервера: реальным временем
    отправки, идентификатором, который сервер канала обозначил это сообщение и так далее.

    \subsubsection*{MessageHandler}
    Все действия между получением сообщения в \inlinecode{ApiWorker.run} и отправкой ответов
    в \inlinecode{ApiWrapper.send_answers} и сохранением в базу будет скрывать в себе метод
    \inlinecode{MessageHandler.handle}. Для входящих сообщений от пользователя обрабатывать
    сообщения будет IncomingHandler, для исходящих от оператора и бота -- OutgoingHandler.
    Интерфейс класса MessageHandler представлен в листинге ниже.

    \begin{figure}[!h]
        \centering
        \lstinputlisting[language=Python]{snippets/message_handler.py}
        \caption{Код класса MessageHandler}
        \label{fig:message_handler}
    \end{figure}

    Метод \inlinecode{MessageHandler.notify} здесь исполняет отправку всех уведомлений,
    которые были переданы ему. Под уведомлениями подразумеваются уведомления других служб
    о появлении новых сообщений, базы данных, telegram-логгера и так далее.

    Обработчик входящих сообщений, IncomingHandler, также должен вырабатывать ответ
    к входящему сообщению. Эту задачу он делегирует другому классу -- Scenarist.
    Дополнительно IncomingHandler может исполнять некоторые действия,
    в зависимости от выбранного сценария.
    Общий вид класса IncomingHandler представлен на листинге ниже.

    \begin{figure}[!h]
        \centering
        \lstinputlisting[language=Python]{snippets/incoming_handler.py}
        \caption{Код класса IncomingHandler}
        \label{fig:incoming_handler}
    \end{figure}

    \subsubsection*{Прочие компоненты}
    IScenarist -- интерфейс сценариста, обладает только одним методом:\\
    \inlinecode{IScenarist.run_scenario}, который при реализации, должен будет
    выработать нужную реакцию (ResponseData) на входящее сообщение с набором
    нужных ответов (Answer) и действий (Action).

    Задачу предсказания сценарист делегирует классификатору (Classifier),
    обладающему единственным методом \inlinecode{Classifier.predict}, который
    возвращает объект Prediction с набором меток обнаруженных в тексте сообщения классов.
    По этим меткам и будет составлена ResponseData внутри сценариста.

    Работа с базой данных через объектно-реляционную модель (ОРМ) будет инкапсулирована
    в классе DBProvider.

    \subsection{Диаграммы}
    Теперь, когда мы выполнили описание всех участников обработки сообщений,
    можем для большей наглядности представить их на диаграмме классов. Сам процесс
    обработки одного сообщения изобразим на диаграмме процессов.

    Диаграмма классов представлена на рисунке ниже.
    \begin{figure}[!h]
        \centering
        \includegraphics[width=\linewidth]{static/ClassDiagram.png}
        \caption{Диаграмма классов проекта}
        \label{fig:class-diagram}
    \end{figure}

    % Диаграмма процесса обработки сообщения представлена на рисунке ниже.
    % \begin{figure}[!h]
    %     \centering
    %     % TODO
    %     % \includegraphics[width=\linewidth]{}
    %     \caption{Диаграмма процесса обработки сообщения}
    %     \label{fig:func-schema-before}
    % \end{figure}

    \subsection*{Вывод по главе 2}
    В этой главе мы сформулировали основную концепцию нашей будущей системы, описали основные
    её сущности и способы их взаимодействия. Мы в коде описали сигнатуры их публичных методов базовых
    классов.
    % , и изобразили основные классы и процессы на диаграммах.
    Теперь, мы можем приступать к их реализации в каждом конкретном канале.
